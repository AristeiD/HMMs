import hmms
import pytest
import numpy
import scipy.linalg

EPS = 1e-7



@pytest.fixture
def cthmm():
    """Parameters for cthmm of 3 hidden states and 3  output variables"""
    Q = numpy.array( [[-0.375,0.125,0.25],[0.25,-0.5,0.25],[0.25,0.125,-0.375]] )
    B = numpy.array( [[0.8,0.05,0.15],[0.05,0.9,0.05],[0.2,0.05,0.75]] )
    Pi = numpy.array( [0.6,0,0.4] )
    return hmms.CtHMM(Q,B,Pi)

@pytest.fixture
def dthmm( cthmm ):
    """The discrete model, created so it behaves identical to the given continuous."""
    return hmms.DtHMM( *get_dthmm_params(cthmm) )



# TODO parametrize number of seq, ..
def test_discrete_compare( dthmm ):
    """Test will run EM algorithms for parameter estimation, determinically with the same initialization on both models"""
    t, e = create_data( dthmm, (50,50) )

    ct = hmms.CtHMM.random(3,3)
    dt = hmms.DtHMM( *get_dthmm_params(ct) )

    compare_parameters_no_sort( dt,  hmms.DtHMM( *get_dthmm_params(ct) ) )

    print("A",dt.a)
    print("Q",ct.q)

    dt.baum_welch(e,1)
    ct.baum_welch(t,e, 1)

    print("dt-matrices")
    print("ct-matrices")


    assert compare_parameters_no_sort( dt,  hmms.DtHMM( *get_dthmm_params(ct) )   )




def DEPtest_main():

    hmm = hmms.CtHMM.random( 2,2 )
    s,t,e = hmm.generate( 20 )
    print( hmm.b  )
    print(s)
    print(t)
    print(e)

    hmm.zmaz_ma( t )

    #hmm.forward( t, e )
    #hmm.backward( t, e )

    hmm2 = hmms.CtHMM.random( 2, 2 )


    #print( hmm.pi )
    print( hmm.q )
    #print( hmm.b )
    print("iter: 0")
    #print( hmm2.pi )
    print( hmm2.q )
    #print( hmm2.b )

    hmm2.baum_welch( numpy.array([t]),numpy.array([e]),10)

    assert False




@pytest.fixture
def small_hmm():
    """Create small DtHMM and basic emission sequence for testing of basic functionality"""
    A = numpy.array([[0.9,0.1],[0.4,0.6]])
    B = numpy.array([[0.9,0.1],[0.2,0.8]])
    pi = numpy.array( [0.8,0.2] )
    hmm = hmms.DtHMM(A,B,pi)

    emissions = numpy.array([0,1])
    return ( hmm, emissions )

def test_forward( small_hmm ):
    """Test forward algorithm"""
    hmm, em = small_hmm

    A = numpy.array( [[0.72,0.04],[0.0664,0.0768]] )
    X = numpy.exp( hmm.forward(em) )

    assert float_equal_mat( A, X )

def test_meow():
    hmm = hmms.CtHMM.random(1,1)
    hmm.meow()
    assert True

def get_dthmm_params( cthmm ):
    """given the cthmm get parameters for dthmm"""
    A = scipy.linalg.expm( cthmm.q )  #the transition rate is set as the one time unit probabilities of continuos model
    B = cthmm.b
    Pi = cthmm.pi
    return (A,B,Pi)


def create_data( dthmm, size ):
    """Create output variables and time sequences generated by dthmm
       size = ( number of sequences, length of sequences  )
    """

    e = numpy.empty( size, dtype=int )
    t = numpy.empty( size, dtype=int )

    for i in range( size[0] ):
        e[i] = dthmm.generate( size[1] )[1]
        t[i] = numpy.arange(  size[1] )

    return (t,e)

###Common methods TODO - move in separate file

def compare_parameters_no_sort( m1, m2, eps = EPS ):
    """Compare whole hmm parameters"""

    #Notice: sort_rows is needed, because any permutation of hidden states is acceptable
    ok  = float_equal_mat( m1.a,  m2.a, eps )
    ok &= float_equal_mat( m1.b,  m2.b, eps )
    ok &= float_equal_mat( m1.pi, m2.pi,eps )

    return ok


def compare_parameters( m1, m2, eps = EPS ):
    """Compare whole hmm parameters"""

    #Notice: sort_rows is needed, because any permutation of hidden states is acceptable
    ok  = float_equal_mat( sort_mat(m1.a),  sort_mat(m2.a), eps )
    ok &= float_equal_mat( sort_mat(m1.b),  sort_mat(m2.b), eps )
    ok &= float_equal_mat( numpy.sort(m1.pi), numpy.sort(m2.pi),eps )

    return ok

def get_hash( a ):
    """Return hash of the numpy vector or the number itself, if it is float"""
    val = 0
    for i in a:
        val += i
        val *= 10
    return val

def sort_rows( m ):
    """Sort rows in numpy array in some deterministic order"""
    sm = numpy.zeros( m.shape[0] )
    for i,a in enumerate(m):
        sm[i] = get_hash( a )
    return m[ numpy.argsort( sm ),:]

def sort_mat( m ):
    """Sort matrix in the way, so the all hidden state permutation will form the same matrix"""
    print("m")
    print(m)
    m = sort_rows(m)
    print(m)
    m = sort_rows(m.T)
    print(m)
    return m

def float_equal( a , b , eps = EPS):
    """Compare two floats with possible error EPS"""
    print(a,b)
    return numpy.fabs(a-b) < eps

def float_equal_mat( A , B, eps = EPS):
    """Takes two numpy arrays or vectors and tells if they are equal (with possible EPS error caused by double imprecision)"""
    print("#####Compare_matrices#####")
    print(A)
    print("-"*10)
    print(B)
    print("#"*10)
    for a,b in zip( A.flatten(), B.flatten() ):
        if numpy.fabs(a-b) > eps :
            print("Do not equal!")
            return False
    return True

