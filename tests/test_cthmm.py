import hmms
import pytest
import numpy
import scipy.linalg

EPS = 1e-7

@pytest.fixture
def cthmm():
    """Parameters for cthmm of 3 hidden states and 3  output variables"""
    Q = numpy.array( [[-0.375,0.125,0.25],[0.25,-0.5,0.25],[0.25,0.125,-0.375]] )
    B = numpy.array( [[0.8,0.05,0.15],[0.05,0.9,0.05],[0.2,0.05,0.75]] )
    Pi = numpy.array( [0.6,0,0.4] )
    return hmms.CtHMM(Q,B,Pi)

@pytest.fixture
def dthmm( cthmm ):
    """The discrete model, created so it behaves identical to the given continuous."""
    return hmms.DtHMM( *get_dthmm_params(cthmm) )


def test_compare_state_probs_with_discrete( dthmm ):
    """Test will run algorithms for counting state probability, determinically with the same initialization for both models"""
    t, e = create_data( dthmm, (1,100) )

    ct = hmms.CtHMM.random(3,3)
    dt = hmms.DtHMM( *get_dthmm_params(ct) )

    assert compare_parameters_no_sort( dt,  hmms.DtHMM( *get_dthmm_params(ct) ) )

    row = e[0]
    trow = t[0]

    #ct
    alpha = ct.forward ( trow, row )
    beta =  ct.backward( trow, row )
    gamma = ct.single_state_prob( alpha, beta )
    ksi = ct.double_state_prob( alpha, beta, trow, row )
    #dt
    d_alpha = dt.forward ( row )
    d_beta =  dt.backward( row )
    d_gamma = dt.single_state_prob( d_alpha, d_beta )
    d_ksi = dt.double_state_prob( d_alpha, d_beta, row )

    assert float_equal_mat( gamma, d_gamma  )
    assert float_equal_mat( ksi[0], d_ksi  )

"""
@pytest.fixture
def vi_data( ):
    e = numpy.array([ [0,0,1,0,1,0],[0,1,2,0,1,0],[2,2,0,1,0,2] ])
    t = numpy.array([ [0,5,8,9,14,19],[0,3,6,7,12,13],[0,5,6,11,14,19] ]) #tree various time intervals
    return (t,e)
"""

@pytest.mark.parametrize("t,e,num", [
    (numpy.array([ [0,5,8,9,14,19],[0,3,6,7,12,13],[0,5,6,11,14,19] ]),
     numpy.array([ [0,0,1,0,1,0],[0,1,2,0,1,0],[2,2,0,1,0,2] ]),
     3
    ),
    (numpy.array([ [0,1,8,16,19,29],[0,2,60,77,120,133],[0,50,61,70,77,79] ]),
     numpy.array([ [0,0,1,0,1,0],[0,1,2,0,1,0],[2,2,0,1,0,2] ]),
     13
    ),
    (numpy.array([ [0,1,8,16,19,29],[0,2,60,77,120,133],[0,50,61,70,77,79] ]),
     numpy.array([ [0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0] ]),
     13
    ),
    (numpy.array([ [0,1,8,16,19,29],[0,2,60,77,120,133],[0,50,61,70,77,79] ]),
     numpy.array([ [1,1,1,1,1,0],[1,1,0,0,0,0],[1,1,0,0,0,0] ]),   #impossibility of init model
     13
    )

])
def test_time_intervals_mapping( t,e,num, cthmm ):
    """test if the time intervals compress to uniq intervals correctly.
    Training data of various time intervals.
    Data are created in the way so it encompass zero probability -> -inf logprobability.
    """
    cthmm.baum_welch( t, e , 3)

    assert cthmm.time_n == num


def DEPRECIATEDtest_main():

    hmm = hmms.CtHMM.random( 2,2 )
    s,t,e = hmm.generate( 20 )
    print( hmm.b  )
    print(s)
    print(t)
    print(e)

    hmm.zmaz_ma( t )

    #hmm.forward( t, e )
    #hmm.backward( t, e )

    hmm2 = hmms.CtHMM.random( 2, 2 )


    #print( hmm.pi )
    print( hmm.q )
    #print( hmm.b )
    print("iter: 0")
    #print( hmm2.pi )
    print( hmm2.q )
    #print( hmm2.b )

    hmm2.baum_welch( numpy.array([t]),numpy.array([e]),10)

    assert False




@pytest.fixture
def small_hmm():
    """Create small DtHMM and basic emission sequence for testing of basic functionality"""
    A = numpy.array([[0.9,0.1],[0.4,0.6]])
    B = numpy.array([[0.9,0.1],[0.2,0.8]])
    pi = numpy.array( [0.8,0.2] )
    hmm = hmms.DtHMM(A,B,pi)

    emissions = numpy.array([0,1])
    return ( hmm, emissions )

def test_forward( small_hmm ):
    """Test forward algorithm"""
    hmm, em = small_hmm

    A = numpy.array( [[0.72,0.04],[0.0664,0.0768]] )
    X = numpy.exp( hmm.forward(em) )

    assert float_equal_mat( A, X )

def test_meow():
    hmm = hmms.CtHMM.random(1,1)
    hmm.meow()
    assert True

def get_dthmm_params( cthmm ):
    """given the cthmm get parameters for dthmm"""
    A = scipy.linalg.expm( cthmm.q )  #the transition rate is set as the one time unit probabilities of continuos model
    B = cthmm.b
    Pi = cthmm.pi
    return (A,B,Pi)


def create_data( dthmm, size ):
    """Create output variables and time sequences generated by dthmm
       size = ( number of sequences, length of sequences  )
    """

    e = numpy.empty( size, dtype=int )
    t = numpy.empty( size, dtype=int )

    for i in range( size[0] ):
        e[i] = dthmm.generate( size[1] )[1]
        t[i] = numpy.arange(  size[1] )

    return (t,e)

###Common methods TODO - move in separate file

def compare_parameters_no_sort( m1, m2, eps = EPS ):
    """Compare whole hmm parameters"""

    #Notice: sort_rows is needed, because any permutation of hidden states is acceptable
    ok  = float_equal_mat( m1.a,  m2.a, eps )
    ok &= float_equal_mat( m1.b,  m2.b, eps )
    ok &= float_equal_mat( m1.pi, m2.pi,eps )

    return ok


def compare_parameters( m1, m2, eps = EPS ):
    """Compare whole hmm parameters"""

    #Notice: sort_rows is needed, because any permutation of hidden states is acceptable
    ok  = float_equal_mat( sort_mat(m1.a),  sort_mat(m2.a), eps )
    ok &= float_equal_mat( sort_mat(m1.b),  sort_mat(m2.b), eps )
    ok &= float_equal_mat( numpy.sort(m1.pi), numpy.sort(m2.pi),eps )

    return ok

def get_hash( a ):
    """Return hash of the numpy vector or the number itself, if it is float"""
    val = 0
    for i in a:
        val += i
        val *= 10
    return val

def sort_rows( m ):
    """Sort rows in numpy array in some deterministic order"""
    sm = numpy.zeros( m.shape[0] )
    for i,a in enumerate(m):
        sm[i] = get_hash( a )
    return m[ numpy.argsort( sm ),:]

def sort_mat( m ):
    """Sort matrix in the way, so the all hidden state permutation will form the same matrix"""
    print("m")
    print(m)
    m = sort_rows(m)
    print(m)
    m = sort_rows(m.T)
    print(m)
    return m

def float_equal( a , b , eps = EPS):
    """Compare two floats with possible error EPS"""
    print(a,b)
    return numpy.fabs(a-b) < eps

def float_equal_mat( A , B, eps = EPS):
    """Takes two numpy arrays or vectors and tells if they are equal (with possible EPS error caused by double imprecision)"""
    print("#####Compare_matrices#####")
    print(A)
    print("-"*10)
    print(B)
    print("#"*10)
    for a,b in zip( A.flatten(), B.flatten() ):
        if numpy.fabs(a-b) > eps :
            print("Do not equal!")
            return False
    return True

